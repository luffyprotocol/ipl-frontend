{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":8215861994775733052,"abi":{"parameters":[{"name":"signer_pub_x_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signer_pub_y_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"selected_player_ids","type":{"kind":"array","length":11,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"selected_players_points","type":{"kind":"array","length":11,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},"visibility":"private"},{"name":"player_points_merkle_paths","type":{"kind":"array","length":11,"type":{"kind":"array","length":6,"type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}},"visibility":"private"},{"name":"all_player_points_merkle_root","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"selected_squad_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"claimed_player_points","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"param_witnesses":{"all_player_points_merkle_root":[{"start":2603,"end":2635}],"claimed_player_points":[{"start":2667,"end":2668}],"player_points_merkle_paths":[{"start":491,"end":2603}],"selected_player_ids":[{"start":128,"end":139}],"selected_players_points":[{"start":139,"end":491}],"selected_squad_hash":[{"start":2635,"end":2667}],"signature":[{"start":64,"end":128}],"signer_pub_x_key":[{"start":0,"end":32}],"signer_pub_y_key":[{"start":32,"end":64}]},"return_type":null,"return_witnesses":[]},"bytecode":"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","debug_symbols":"zdzdih1ndsfhe9GxCXt9VL1r+VZCDkwygYHBE2KfGd97rB5LMnH3SH7EHnxmxP67Ss2vBP302/XTu7/9/T+/+/Gvf//+h3ff/vQu73veffvvP7374X+++/79H/zw43f/++O7b7sf37z7y/f/9e7b6+6fv3n333/9219++dP8+ZvffTRi4tfPRp74zIdz8sOHq/fTh/vn//jm/d3sv/Ruaj78j6Ojfnc35/Gnupv42rupuj5e4DH//MN5ffhs7v3po/Xq3zL749/ytRvPP8WN/+Ne6l95LxUfvjBV/Zkv4meejNN/1hv/XLbX1974VR8vcN3Xbz/8jwvcz77AefYF5tkX2CdfYB7PvkA8+wL57AvUsy/Qz77As5/kefaTPM9+kufZT/I8+0neZz/J++wneZ/9JO+zn+R99pO8z36S99lP8j77Sd5nP8n75Cf5PB7PvkA8+wL57AvUsy/Qz77A9ewL3M++wHn2BebZF3j2kxzPfpLj2U9yPPtJjq9+kjs+fXt85+8v8NVPct/z8W8Q5/cXePVJnvkw2rx/v7lhc2AzsNk/vskHbAI2CZuCTcMGOkjoIKGDhA4SOijooKCDgg4KOijooKCDgg4KOijooKCDhg4aOmjooKGDhg4aOmjooKGDhg4aOriggws6uKCDCzq4oIMLOriggws6uKCDCzq4oYMbOrihgxs6uKGDGzq4oYMbOrihgxs6ONDBgQ4OdHCggwMdHOjgQAcHOjjQwYEOBjoY6GCgg4EOBjoY6GCgg4EOBjoY6GChg4UOFjpY6GChg4UOFjpY6GChg/3jHczjAZuATcKmYNOwuWBzw+bAZmADHQR0ENBBQAcBHQR0AJ444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgiQueuOCJC5644IkLnrjgifvHPbEef9wTf9kEbBI2BZuGzQWbGzYHNgMb6CCgg4AOAjoI6CCgg4AOAjoI6CCgg4AOEjpI6CChg4QOEjpI6CChg4QOEjpI6KCgg4IOCjoo6KCgg4IOCjoo6KCgg4IOGjpo6KChg4YOGjpo6KChg4YOGjpo6OCCDi7o4IIOLujggg4u6OCCDi7o4IIOLujghg5u6OCGDm7o4IYObujghg5u6OCGDm7o4EAHBzo40MGBDg50cKCDAx0c6OBABwc6GOhgoIOBDgY6GOhgoIOBDgY6GOhgoIOFDhY6WOhgoYOFDhY6WOhgoYOFDsATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McET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","file_map":{"25":{"source":"mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(_with_newline: bool, _input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key: [Field], _proof: [Field], _public_inputs: [Field], _key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n","path":"std/lib.nr"},"42":{"source":"mod tests;\nuse dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 6;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    selected_player_ids: [u8; 11],\n    selected_players_points: [[u8; 32]; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    all_player_points_merkle_root: [u8; 32],\n    selected_squad_hash: pub [u8; 32],\n    claimed_player_points: pub u64\n) {\n    ecdsa_verification(\n        signer_pub_x_key,\n        signer_pub_y_key,\n        signature,\n        selected_squad_hash\n    );\n\n    // verify_all_merkle_roots(\n    //     selected_player_ids,\n    //     selected_players_points,\n    //     player_points_merkle_paths,\n    //     all_player_points_merkle_root\n    // );\n\n    let mut calculated_total_points: u64 = 0;\n\n    for point in selected_players_points {\n        for byte in point {\n            calculated_total_points += byte as u64;\n        }\n    }\n    assert(calculated_total_points == claimed_player_points);\n}\n\nfn ecdsa_verification(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    hash: pub [u8; 32]\n) {\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hash);\n\n    println(f\"Computed address: {computedAddress}\");\n    println(f\"Recovered address: {recoveredAddress}\");\n    assert(computedAddress == recoveredAddress);\n}\n\nfn verify_all_merkle_roots(\n    player_ids: [u8; 11],\n    players_points: [[u8; 32]; 11],\n    merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    merkle_root: [u8; 32]\n) {\n    for i in 0..11 {\n        compute_and_verify_merkle_root(players_points[i], player_ids[i], merkle_paths[i], merkle_root);\n    }\n}\n\nfn compute_and_verify_merkle_root(\n    leaf: [u8; 32],\n    leaf_index: u8,\n    proof: [[u8; 32]; MERKLE_DEPTH],\n    all_points_merkle_root: [u8; 32]\n) {\n    let mut computed_merkle_root: [u8; 32] = [0; 32];\n    computed_merkle_root=leaf;\n    let mut leaf_index_mut= leaf_index;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index_mut % 2 == 0 {\n            computed_merkle_root = std::hash::keccak256(concatenate_leafs(computed_merkle_root, proof[i]), 64);\n        } else {\n            computed_merkle_root = std::hash::keccak256(concatenate_leafs(proof[i], computed_merkle_root), 64);\n        }\n        leaf_index_mut = leaf_index_mut / 2;\n    }\n\n    println(f\"Computed merkle root: {computed_merkle_root}\");\n    println(f\"All points merkle root: {all_points_merkle_root}\");\n    assert(computed_merkle_root == all_points_merkle_root);\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n","path":"/Users/gabrielantonyxaviour/Developer/projects/ongoing/zkricket/circuits/src/main.nr"},"43":{"source":"use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"},"44":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"},"45":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"}}}